//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IApiClient {
    /**
     * Get time series analytics data
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param interval (optional) 
     * @return Time series data retrieved successfully
     */
    timeseries(shortCode: string, startDate?: Date | undefined, endDate?: Date | undefined, interval?: string | undefined): Observable<TimeSeriesDataDto>;
    /**
     * Get dashboard overview statistics
     * @return Overview retrieved successfully
     */
    overview(): Observable<DashboardOverviewDto>;
    /**
     * Get geographic analytics data
     * @param shortCode (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Geographic data retrieved successfully
     */
    geographic(shortCode?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<GeographicHeatmapDto>;
    /**
     * Get device breakdown analytics
     * @param shortCode (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Device data retrieved successfully
     */
    devices(shortCode?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<DeviceBreakdownDto>;
    /**
     * Compare analytics between two periods
     * @param currentStart (optional) 
     * @param currentEnd (optional) 
     * @param previousStart (optional) 
     * @param previousEnd (optional) 
     * @param shortCode (optional) 
     * @return Comparison data retrieved successfully
     */
    compare(currentStart?: Date | undefined, currentEnd?: Date | undefined, previousStart?: Date | undefined, previousEnd?: Date | undefined, shortCode?: string | undefined): Observable<ComparisonDto>;
    rGET(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<void>;
    /**
     * @param x_Api_Version (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    rHEAD(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<void>;
    /**
     * @param x_Api_Version (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    preview(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<PreviewResponse>;
    /**
     * Get detailed URL statistics
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getUrlStatistics(shortCode: string, version: string, startDate?: Date | undefined, endDate?: Date | undefined): Observable<AnalyticsSummary>;
    /**
     * Get top performing URLs
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getTopUrls(version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]>;
    /**
     * Get trending URLs
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getTrendingUrls(version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]>;
    /**
     * Get popular URLs by region
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getRegionalPopularUrls(region: string, version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]>;
    /**
     * Export analytics data
     * @param format (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    exportAnalytics(shortCode: string, version: string, format?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<void>;
    /**
     * Stream real-time analytics
     * @return OK
     */
    streamAnalytics(shortCode: string, version: string): Observable<AnalyticsPoint[]>;
    /**
     * Create multiple shortened URLs
     * @param body (optional) 
     * @return OK
     */
    createBulkUrls(version: string, body?: BulkCreateRequest | undefined): Observable<BulkCreateResponse>;
    /**
     * Delete multiple URLs
     * @param body (optional) 
     * @return OK
     */
    deleteBulkUrls(version: string, body?: BulkDeleteRequest | undefined): Observable<BulkDeleteResponse>;
    /**
     * Update expiration for multiple URLs
     * @param body (optional) 
     * @return OK
     */
    updateBulkUrlExpiration(version: string, body?: BulkUpdateExpirationRequest | undefined): Observable<BulkUpdateResponse>;
    /**
     * Create a shortened URL
     * @param body (optional) 
     * @return Created
     */
    createShortUrl(version: string, body?: CreateUrlDto | undefined): Observable<CreateUrlResponse>;
    /**
     * Get URL information
     * @return OK
     */
    getUrlInfo(shortCode: string, version: string): Observable<UrlStatistics>;
    /**
     * Delete a shortened URL
     * @return No Content
     */
    deleteUrl(shortCode: string, version: string): Observable<void>;
    /**
     * Get user's URLs
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    getMyUrls(version: string, skip?: number | undefined, take?: number | undefined): Observable<UrlStatistics[]>;
    /**
     * Search URLs
     * @param q (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    searchUrls(version: string, q?: string | undefined, skip?: number | undefined, take?: number | undefined): Observable<UrlStatistics[]>;
    /**
     * Check short code availability
     * @return OK
     */
    checkAvailability(shortCode: string, version: string): Observable<any>;
    /**
     * Disable a URL
     * @param body (optional) 
     * @return No Content
     */
    disableUrl(shortCode: string, version: string, body?: DisableUrlDto | undefined): Observable<void>;
    /**
     * Generate QR code for URL
     * @param size (optional) 
     * @param darkColor (optional) 
     * @param lightColor (optional) 
     * @return OK
     */
    generateQRCode(shortCode: string, version: string, size?: number | undefined, darkColor?: string | undefined, lightColor?: string | undefined): Observable<void>;
    /**
     * Get URL preview
     * @param refresh (optional) 
     * @return OK
     */
    getUrlPreview(shortCode: string, version: string, refresh?: boolean | undefined): Observable<UrlPreviewResponse>;
    /**
     * Generate batch QR codes
     * @param body (optional) 
     * @return OK
     */
    generateBatchQRCodes(version: string, body?: BatchQRCodeRequest | undefined): Observable<void>;
    /**
     * Validate URL safety
     * @return OK
     */
    validateUrl(shortCode: string, version: string): Observable<UrlValidationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get time series analytics data
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param interval (optional) 
     * @return Time series data retrieved successfully
     */
    timeseries(shortCode: string, startDate?: Date | undefined, endDate?: Date | undefined, interval?: string | undefined): Observable<TimeSeriesDataDto> {
        let url_ = this.baseUrl + "/api/v1/Dashboard/timeseries/{shortCode}?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (interval === null)
            throw new globalThis.Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimeseries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimeseries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeSeriesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeSeriesDataDto>;
        }));
    }

    protected processTimeseries(response: HttpResponseBase): Observable<TimeSeriesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeSeriesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get dashboard overview statistics
     * @return Overview retrieved successfully
     */
    overview(): Observable<DashboardOverviewDto> {
        let url_ = this.baseUrl + "/api/v1/Dashboard/overview";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOverviewDto>;
        }));
    }

    protected processOverview(response: HttpResponseBase): Observable<DashboardOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get geographic analytics data
     * @param shortCode (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Geographic data retrieved successfully
     */
    geographic(shortCode?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<GeographicHeatmapDto> {
        let url_ = this.baseUrl + "/api/v1/Dashboard/geographic?";
        if (shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' cannot be null.");
        else if (shortCode !== undefined)
            url_ += "shortCode=" + encodeURIComponent("" + shortCode) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeographic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeographic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeographicHeatmapDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeographicHeatmapDto>;
        }));
    }

    protected processGeographic(response: HttpResponseBase): Observable<GeographicHeatmapDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeographicHeatmapDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get device breakdown analytics
     * @param shortCode (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Device data retrieved successfully
     */
    devices(shortCode?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<DeviceBreakdownDto> {
        let url_ = this.baseUrl + "/api/v1/Dashboard/devices?";
        if (shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' cannot be null.");
        else if (shortCode !== undefined)
            url_ += "shortCode=" + encodeURIComponent("" + shortCode) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceBreakdownDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceBreakdownDto>;
        }));
    }

    protected processDevices(response: HttpResponseBase): Observable<DeviceBreakdownDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceBreakdownDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Compare analytics between two periods
     * @param currentStart (optional) 
     * @param currentEnd (optional) 
     * @param previousStart (optional) 
     * @param previousEnd (optional) 
     * @param shortCode (optional) 
     * @return Comparison data retrieved successfully
     */
    compare(currentStart?: Date | undefined, currentEnd?: Date | undefined, previousStart?: Date | undefined, previousEnd?: Date | undefined, shortCode?: string | undefined): Observable<ComparisonDto> {
        let url_ = this.baseUrl + "/api/v1/Dashboard/compare?";
        if (currentStart === null)
            throw new globalThis.Error("The parameter 'currentStart' cannot be null.");
        else if (currentStart !== undefined)
            url_ += "currentStart=" + encodeURIComponent(currentStart ? "" + currentStart.toISOString() : "") + "&";
        if (currentEnd === null)
            throw new globalThis.Error("The parameter 'currentEnd' cannot be null.");
        else if (currentEnd !== undefined)
            url_ += "currentEnd=" + encodeURIComponent(currentEnd ? "" + currentEnd.toISOString() : "") + "&";
        if (previousStart === null)
            throw new globalThis.Error("The parameter 'previousStart' cannot be null.");
        else if (previousStart !== undefined)
            url_ += "previousStart=" + encodeURIComponent(previousStart ? "" + previousStart.toISOString() : "") + "&";
        if (previousEnd === null)
            throw new globalThis.Error("The parameter 'previousEnd' cannot be null.");
        else if (previousEnd !== undefined)
            url_ += "previousEnd=" + encodeURIComponent(previousEnd ? "" + previousEnd.toISOString() : "") + "&";
        if (shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' cannot be null.");
        else if (shortCode !== undefined)
            url_ += "shortCode=" + encodeURIComponent("" + shortCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComparisonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComparisonDto>;
        }));
    }

    protected processCompare(response: HttpResponseBase): Observable<ComparisonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComparisonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    rGET(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/r/{shortCode}?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (api_version === null)
            throw new globalThis.Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 302) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Found", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 410) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result410: any = null;
            let resultData410 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result410 = ProblemDetails.fromJS(resultData410);
            return throwException("Gone", status, _responseText, _headers, result410);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Too Many Requests", status, _responseText, _headers, result429);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param x_Api_Version (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    rHEAD(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/r/{shortCode}?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (api_version === null)
            throw new globalThis.Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
            })
        };

        return this.http.request("head", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRHEAD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRHEAD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRHEAD(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param x_Api_Version (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    preview(shortCode: string, x_Api_Version?: string | undefined, api_version?: string | undefined): Observable<PreviewResponse> {
        let url_ = this.baseUrl + "/r/{shortCode}/preview?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (api_version === null)
            throw new globalThis.Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreviewResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreviewResponse>;
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<PreviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get detailed URL statistics
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getUrlStatistics(shortCode: string, version: string, startDate?: Date | undefined, endDate?: Date | undefined): Observable<AnalyticsSummary> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/{shortCode}/statistics?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrlStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrlStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnalyticsSummary>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnalyticsSummary>;
        }));
    }

    protected processGetUrlStatistics(response: HttpResponseBase): Observable<AnalyticsSummary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnalyticsSummary.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get top performing URLs
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getTopUrls(version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/top?";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (timeWindowHours === null)
            throw new globalThis.Error("The parameter 'timeWindowHours' cannot be null.");
        else if (timeWindowHours !== undefined)
            url_ += "timeWindowHours=" + encodeURIComponent("" + timeWindowHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularUrl[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularUrl[]>;
        }));
    }

    protected processGetTopUrls(response: HttpResponseBase): Observable<PopularUrl[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PopularUrl.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get trending URLs
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getTrendingUrls(version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/trending?";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (timeWindowHours === null)
            throw new globalThis.Error("The parameter 'timeWindowHours' cannot be null.");
        else if (timeWindowHours !== undefined)
            url_ += "timeWindowHours=" + encodeURIComponent("" + timeWindowHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrendingUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrendingUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularUrl[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularUrl[]>;
        }));
    }

    protected processGetTrendingUrls(response: HttpResponseBase): Observable<PopularUrl[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PopularUrl.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get popular URLs by region
     * @param count (optional) 
     * @param timeWindowHours (optional) 
     * @return OK
     */
    getRegionalPopularUrls(region: string, version: string, count?: number | undefined, timeWindowHours?: number | undefined): Observable<PopularUrl[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/regional/{region}?";
        if (region === undefined || region === null)
            throw new globalThis.Error("The parameter 'region' must be defined.");
        url_ = url_.replace("{region}", encodeURIComponent("" + region));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (timeWindowHours === null)
            throw new globalThis.Error("The parameter 'timeWindowHours' cannot be null.");
        else if (timeWindowHours !== undefined)
            url_ += "timeWindowHours=" + encodeURIComponent("" + timeWindowHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalPopularUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalPopularUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularUrl[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularUrl[]>;
        }));
    }

    protected processGetRegionalPopularUrls(response: HttpResponseBase): Observable<PopularUrl[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PopularUrl.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Export analytics data
     * @param format (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    exportAnalytics(shortCode: string, version: string, format?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/{shortCode}/export?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAnalytics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAnalytics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExportAnalytics(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Stream real-time analytics
     * @return OK
     */
    streamAnalytics(shortCode: string, version: string): Observable<AnalyticsPoint[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlAnalytics/{shortCode}/stream";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStreamAnalytics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStreamAnalytics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnalyticsPoint[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnalyticsPoint[]>;
        }));
    }

    protected processStreamAnalytics(response: HttpResponseBase): Observable<AnalyticsPoint[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnalyticsPoint.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple shortened URLs
     * @param body (optional) 
     * @return OK
     */
    createBulkUrls(version: string, body?: BulkCreateRequest | undefined): Observable<BulkCreateResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlBulk/create";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulkUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulkUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkCreateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkCreateResponse>;
        }));
    }

    protected processCreateBulkUrls(response: HttpResponseBase): Observable<BulkCreateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkCreateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Too Many Requests", status, _responseText, _headers, result429);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple URLs
     * @param body (optional) 
     * @return OK
     */
    deleteBulkUrls(version: string, body?: BulkDeleteRequest | undefined): Observable<BulkDeleteResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlBulk/delete";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBulkUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBulkUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkDeleteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkDeleteResponse>;
        }));
    }

    protected processDeleteBulkUrls(response: HttpResponseBase): Observable<BulkDeleteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkDeleteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update expiration for multiple URLs
     * @param body (optional) 
     * @return OK
     */
    updateBulkUrlExpiration(version: string, body?: BulkUpdateExpirationRequest | undefined): Observable<BulkUpdateResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlBulk/update-expiration";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBulkUrlExpiration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBulkUrlExpiration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkUpdateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkUpdateResponse>;
        }));
    }

    protected processUpdateBulkUrlExpiration(response: HttpResponseBase): Observable<BulkUpdateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a shortened URL
     * @param body (optional) 
     * @return Created
     */
    createShortUrl(version: string, body?: CreateUrlDto | undefined): Observable<CreateUrlResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShortUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShortUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUrlResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUrlResponse>;
        }));
    }

    protected processCreateShortUrl(response: HttpResponseBase): Observable<CreateUrlResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateUrlResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Too Many Requests", status, _responseText, _headers, result429);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get URL information
     * @return OK
     */
    getUrlInfo(shortCode: string, version: string): Observable<UrlStatistics> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/{shortCode}";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrlInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrlInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UrlStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UrlStatistics>;
        }));
    }

    protected processGetUrlInfo(response: HttpResponseBase): Observable<UrlStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a shortened URL
     * @return No Content
     */
    deleteUrl(shortCode: string, version: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/{shortCode}";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUrl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user's URLs
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    getMyUrls(version: string, skip?: number | undefined, take?: number | undefined): Observable<UrlStatistics[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/my-urls?";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UrlStatistics[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UrlStatistics[]>;
        }));
    }

    protected processGetMyUrls(response: HttpResponseBase): Observable<UrlStatistics[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UrlStatistics.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search URLs
     * @param q (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    searchUrls(version: string, q?: string | undefined, skip?: number | undefined, take?: number | undefined): Observable<UrlStatistics[]> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/search?";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (q === null)
            throw new globalThis.Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UrlStatistics[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UrlStatistics[]>;
        }));
    }

    protected processSearchUrls(response: HttpResponseBase): Observable<UrlStatistics[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UrlStatistics.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Check short code availability
     * @return OK
     */
    checkAvailability(shortCode: string, version: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/available/{shortCode}";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAvailability(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAvailability(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processCheckAvailability(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Disable a URL
     * @param body (optional) 
     * @return No Content
     */
    disableUrl(shortCode: string, version: string, body?: DisableUrlDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v{version}/UrlManagement/{shortCode}/disable";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableUrl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Generate QR code for URL
     * @param size (optional) 
     * @param darkColor (optional) 
     * @param lightColor (optional) 
     * @return OK
     */
    generateQRCode(shortCode: string, version: string, size?: number | undefined, darkColor?: string | undefined, lightColor?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v{version}/UrlUtilities/{shortCode}/qr?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (darkColor === null)
            throw new globalThis.Error("The parameter 'darkColor' cannot be null.");
        else if (darkColor !== undefined)
            url_ += "darkColor=" + encodeURIComponent("" + darkColor) + "&";
        if (lightColor === null)
            throw new globalThis.Error("The parameter 'lightColor' cannot be null.");
        else if (lightColor !== undefined)
            url_ += "lightColor=" + encodeURIComponent("" + lightColor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateQRCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateQRCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateQRCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get URL preview
     * @param refresh (optional) 
     * @return OK
     */
    getUrlPreview(shortCode: string, version: string, refresh?: boolean | undefined): Observable<UrlPreviewResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlUtilities/{shortCode}/preview?";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (refresh === null)
            throw new globalThis.Error("The parameter 'refresh' cannot be null.");
        else if (refresh !== undefined)
            url_ += "refresh=" + encodeURIComponent("" + refresh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrlPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrlPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UrlPreviewResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UrlPreviewResponse>;
        }));
    }

    protected processGetUrlPreview(response: HttpResponseBase): Observable<UrlPreviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlPreviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Generate batch QR codes
     * @param body (optional) 
     * @return OK
     */
    generateBatchQRCodes(version: string, body?: BatchQRCodeRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v{version}/UrlUtilities/qr/batch";
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBatchQRCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBatchQRCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateBatchQRCodes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Validate URL safety
     * @return OK
     */
    validateUrl(shortCode: string, version: string): Observable<UrlValidationResponse> {
        let url_ = this.baseUrl + "/api/v{version}/UrlUtilities/{shortCode}/validate";
        if (shortCode === undefined || shortCode === null)
            throw new globalThis.Error("The parameter 'shortCode' must be defined.");
        url_ = url_.replace("{shortCode}", encodeURIComponent("" + shortCode));
        if (version === undefined || version === null)
            throw new globalThis.Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UrlValidationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UrlValidationResponse>;
        }));
    }

    protected processValidateUrl(response: HttpResponseBase): Observable<UrlValidationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlValidationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AnalyticsPoint implements IAnalyticsPoint {
    timestamp?: Date;
    accessCount?: number;
    accessRate?: number;
    metadata?: { [key: string]: any; } | undefined;

    constructor(data?: IAnalyticsPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : undefined as any;
            this.accessCount = _data["accessCount"];
            this.accessRate = _data["accessRate"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (this.metadata as any)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): AnalyticsPoint {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyticsPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined as any;
        data["accessCount"] = this.accessCount;
        data["accessRate"] = this.accessRate;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (data["metadata"] as any)[key] = (this.metadata as any)[key];
            }
        }
        return data;
    }
}

export interface IAnalyticsPoint {
    timestamp?: Date;
    accessCount?: number;
    accessRate?: number;
    metadata?: { [key: string]: any; } | undefined;
}

export class AnalyticsSummary implements IAnalyticsSummary {
    shortCode?: string | undefined;
    totalAccesses?: number;
    uniqueVisitors?: number;
    countryBreakdown?: { [key: string]: number; } | undefined;
    deviceBreakdown?: { [key: string]: number; } | undefined;
    timeSeriesData?: { [key: string]: number; } | undefined;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IAnalyticsSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.totalAccesses = _data["totalAccesses"];
            this.uniqueVisitors = _data["uniqueVisitors"];
            if (_data["countryBreakdown"]) {
                this.countryBreakdown = {} as any;
                for (let key in _data["countryBreakdown"]) {
                    if (_data["countryBreakdown"].hasOwnProperty(key))
                        (this.countryBreakdown as any)![key] = _data["countryBreakdown"][key];
                }
            }
            if (_data["deviceBreakdown"]) {
                this.deviceBreakdown = {} as any;
                for (let key in _data["deviceBreakdown"]) {
                    if (_data["deviceBreakdown"].hasOwnProperty(key))
                        (this.deviceBreakdown as any)![key] = _data["deviceBreakdown"][key];
                }
            }
            if (_data["timeSeriesData"]) {
                this.timeSeriesData = {} as any;
                for (let key in _data["timeSeriesData"]) {
                    if (_data["timeSeriesData"].hasOwnProperty(key))
                        (this.timeSeriesData as any)![key] = _data["timeSeriesData"][key];
                }
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AnalyticsSummary {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyticsSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["totalAccesses"] = this.totalAccesses;
        data["uniqueVisitors"] = this.uniqueVisitors;
        if (this.countryBreakdown) {
            data["countryBreakdown"] = {};
            for (let key in this.countryBreakdown) {
                if (this.countryBreakdown.hasOwnProperty(key))
                    (data["countryBreakdown"] as any)[key] = (this.countryBreakdown as any)[key];
            }
        }
        if (this.deviceBreakdown) {
            data["deviceBreakdown"] = {};
            for (let key in this.deviceBreakdown) {
                if (this.deviceBreakdown.hasOwnProperty(key))
                    (data["deviceBreakdown"] as any)[key] = (this.deviceBreakdown as any)[key];
            }
        }
        if (this.timeSeriesData) {
            data["timeSeriesData"] = {};
            for (let key in this.timeSeriesData) {
                if (this.timeSeriesData.hasOwnProperty(key))
                    (data["timeSeriesData"] as any)[key] = (this.timeSeriesData as any)[key];
            }
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IAnalyticsSummary {
    shortCode?: string | undefined;
    totalAccesses?: number;
    uniqueVisitors?: number;
    countryBreakdown?: { [key: string]: number; } | undefined;
    deviceBreakdown?: { [key: string]: number; } | undefined;
    timeSeriesData?: { [key: string]: number; } | undefined;
    startDate?: Date;
    endDate?: Date;
}

export class BatchQRCodeRequest implements IBatchQRCodeRequest {
    shortCodes?: string[] | undefined;
    size?: number;

    constructor(data?: IBatchQRCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["shortCodes"])) {
                this.shortCodes = [] as any;
                for (let item of _data["shortCodes"])
                    this.shortCodes!.push(item);
            }
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): BatchQRCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BatchQRCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.shortCodes)) {
            data["shortCodes"] = [];
            for (let item of this.shortCodes)
                data["shortCodes"].push(item);
        }
        data["size"] = this.size;
        return data;
    }
}

export interface IBatchQRCodeRequest {
    shortCodes?: string[] | undefined;
    size?: number;
}

export class BulkCreateRequest implements IBulkCreateRequest {
    urls?: CreateUrlDto[] | undefined;

    constructor(data?: IBulkCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["urls"])) {
                this.urls = [] as any;
                for (let item of _data["urls"])
                    this.urls!.push(CreateUrlDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.urls)) {
            data["urls"] = [];
            for (let item of this.urls)
                data["urls"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBulkCreateRequest {
    urls?: CreateUrlDto[] | undefined;
}

export class BulkCreateResponse implements IBulkCreateResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: CreateUrlResult[] | undefined;

    constructor(data?: IBulkCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRequested = _data["totalRequested"];
            this.successCount = _data["successCount"];
            this.failureCount = _data["failureCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CreateUrlResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRequested"] = this.totalRequested;
        data["successCount"] = this.successCount;
        data["failureCount"] = this.failureCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBulkCreateResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: CreateUrlResult[] | undefined;
}

export class BulkDeleteRequest implements IBulkDeleteRequest {
    shortCodes?: string[] | undefined;

    constructor(data?: IBulkDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["shortCodes"])) {
                this.shortCodes = [] as any;
                for (let item of _data["shortCodes"])
                    this.shortCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.shortCodes)) {
            data["shortCodes"] = [];
            for (let item of this.shortCodes)
                data["shortCodes"].push(item);
        }
        return data;
    }
}

export interface IBulkDeleteRequest {
    shortCodes?: string[] | undefined;
}

export class BulkDeleteResponse implements IBulkDeleteResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: DeleteUrlResult[] | undefined;

    constructor(data?: IBulkDeleteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRequested = _data["totalRequested"];
            this.successCount = _data["successCount"];
            this.failureCount = _data["failureCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DeleteUrlResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkDeleteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRequested"] = this.totalRequested;
        data["successCount"] = this.successCount;
        data["failureCount"] = this.failureCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBulkDeleteResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: DeleteUrlResult[] | undefined;
}

export class BulkUpdateExpirationRequest implements IBulkUpdateExpirationRequest {
    updates?: UrlExpirationUpdate[] | undefined;

    constructor(data?: IBulkUpdateExpirationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["updates"])) {
                this.updates = [] as any;
                for (let item of _data["updates"])
                    this.updates!.push(UrlExpirationUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkUpdateExpirationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateExpirationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updates)) {
            data["updates"] = [];
            for (let item of this.updates)
                data["updates"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBulkUpdateExpirationRequest {
    updates?: UrlExpirationUpdate[] | undefined;
}

export class BulkUpdateResponse implements IBulkUpdateResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: UpdateUrlResult[] | undefined;

    constructor(data?: IBulkUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRequested = _data["totalRequested"];
            this.successCount = _data["successCount"];
            this.failureCount = _data["failureCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UpdateUrlResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRequested"] = this.totalRequested;
        data["successCount"] = this.successCount;
        data["failureCount"] = this.failureCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IBulkUpdateResponse {
    totalRequested?: number;
    successCount?: number;
    failureCount?: number;
    results?: UpdateUrlResult[] | undefined;
}

export class CityDataDto implements ICityDataDto {
    countryCode?: string | undefined;
    cityName?: string | undefined;
    clicks?: number;
    percentage?: number;
    latitude?: number;
    longitude?: number;

    constructor(data?: ICityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.cityName = _data["cityName"];
            this.clicks = _data["clicks"];
            this.percentage = _data["percentage"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): CityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["cityName"] = this.cityName;
        data["clicks"] = this.clicks;
        data["percentage"] = this.percentage;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface ICityDataDto {
    countryCode?: string | undefined;
    cityName?: string | undefined;
    clicks?: number;
    percentage?: number;
    latitude?: number;
    longitude?: number;
}

export class ComparisonDto implements IComparisonDto {
    currentPeriod?: DateRangeDto;
    previousPeriod?: DateRangeDto;
    metrics?: ComparisonMetricsDto;
    series?: ComparisonSeriesDto[] | undefined;

    constructor(data?: IComparisonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPeriod = _data["currentPeriod"] ? DateRangeDto.fromJS(_data["currentPeriod"]) : undefined as any;
            this.previousPeriod = _data["previousPeriod"] ? DateRangeDto.fromJS(_data["previousPeriod"]) : undefined as any;
            this.metrics = _data["metrics"] ? ComparisonMetricsDto.fromJS(_data["metrics"]) : undefined as any;
            if (Array.isArray(_data["series"])) {
                this.series = [] as any;
                for (let item of _data["series"])
                    this.series!.push(ComparisonSeriesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ComparisonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPeriod"] = this.currentPeriod ? this.currentPeriod.toJSON() : undefined as any;
        data["previousPeriod"] = this.previousPeriod ? this.previousPeriod.toJSON() : undefined as any;
        data["metrics"] = this.metrics ? this.metrics.toJSON() : undefined as any;
        if (Array.isArray(this.series)) {
            data["series"] = [];
            for (let item of this.series)
                data["series"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IComparisonDto {
    currentPeriod?: DateRangeDto;
    previousPeriod?: DateRangeDto;
    metrics?: ComparisonMetricsDto;
    series?: ComparisonSeriesDto[] | undefined;
}

export class ComparisonMetricsDto implements IComparisonMetricsDto {
    totalClicks?: ComparisonValueDto;
    uniqueVisitors?: ComparisonValueDto;
    newUrls?: ComparisonValueDto;
    avgClicksPerUrl?: ComparisonValueDto;

    constructor(data?: IComparisonMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalClicks = _data["totalClicks"] ? ComparisonValueDto.fromJS(_data["totalClicks"]) : undefined as any;
            this.uniqueVisitors = _data["uniqueVisitors"] ? ComparisonValueDto.fromJS(_data["uniqueVisitors"]) : undefined as any;
            this.newUrls = _data["newUrls"] ? ComparisonValueDto.fromJS(_data["newUrls"]) : undefined as any;
            this.avgClicksPerUrl = _data["avgClicksPerUrl"] ? ComparisonValueDto.fromJS(_data["avgClicksPerUrl"]) : undefined as any;
        }
    }

    static fromJS(data: any): ComparisonMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalClicks"] = this.totalClicks ? this.totalClicks.toJSON() : undefined as any;
        data["uniqueVisitors"] = this.uniqueVisitors ? this.uniqueVisitors.toJSON() : undefined as any;
        data["newUrls"] = this.newUrls ? this.newUrls.toJSON() : undefined as any;
        data["avgClicksPerUrl"] = this.avgClicksPerUrl ? this.avgClicksPerUrl.toJSON() : undefined as any;
        return data;
    }
}

export interface IComparisonMetricsDto {
    totalClicks?: ComparisonValueDto;
    uniqueVisitors?: ComparisonValueDto;
    newUrls?: ComparisonValueDto;
    avgClicksPerUrl?: ComparisonValueDto;
}

export class ComparisonSeriesDto implements IComparisonSeriesDto {
    currentTimestamp?: Date;
    previousTimestamp?: Date;
    currentClicks?: number;
    previousClicks?: number;

    constructor(data?: IComparisonSeriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentTimestamp = _data["currentTimestamp"] ? new Date(_data["currentTimestamp"].toString()) : undefined as any;
            this.previousTimestamp = _data["previousTimestamp"] ? new Date(_data["previousTimestamp"].toString()) : undefined as any;
            this.currentClicks = _data["currentClicks"];
            this.previousClicks = _data["previousClicks"];
        }
    }

    static fromJS(data: any): ComparisonSeriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonSeriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentTimestamp"] = this.currentTimestamp ? this.currentTimestamp.toISOString() : undefined as any;
        data["previousTimestamp"] = this.previousTimestamp ? this.previousTimestamp.toISOString() : undefined as any;
        data["currentClicks"] = this.currentClicks;
        data["previousClicks"] = this.previousClicks;
        return data;
    }
}

export interface IComparisonSeriesDto {
    currentTimestamp?: Date;
    previousTimestamp?: Date;
    currentClicks?: number;
    previousClicks?: number;
}

export class ComparisonValueDto implements IComparisonValueDto {
    currentValue?: number;
    previousValue?: number;
    absoluteChange?: number;
    percentChange?: number;
    trend?: string | undefined;

    constructor(data?: IComparisonValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentValue = _data["currentValue"];
            this.previousValue = _data["previousValue"];
            this.absoluteChange = _data["absoluteChange"];
            this.percentChange = _data["percentChange"];
            this.trend = _data["trend"];
        }
    }

    static fromJS(data: any): ComparisonValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentValue"] = this.currentValue;
        data["previousValue"] = this.previousValue;
        data["absoluteChange"] = this.absoluteChange;
        data["percentChange"] = this.percentChange;
        data["trend"] = this.trend;
        return data;
    }
}

export interface IComparisonValueDto {
    currentValue?: number;
    previousValue?: number;
    absoluteChange?: number;
    percentChange?: number;
    trend?: string | undefined;
}

export class CountryDataDto implements ICountryDataDto {
    countryCode?: string | undefined;
    countryName?: string | undefined;
    clicks?: number;
    percentage?: number;
    latitude?: number;
    longitude?: number;

    constructor(data?: ICountryDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.clicks = _data["clicks"];
            this.percentage = _data["percentage"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): CountryDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["clicks"] = this.clicks;
        data["percentage"] = this.percentage;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface ICountryDataDto {
    countryCode?: string | undefined;
    countryName?: string | undefined;
    clicks?: number;
    percentage?: number;
    latitude?: number;
    longitude?: number;
}

export class CreateUrlDto implements ICreateUrlDto {
    originalUrl!: string;
    customAlias?: string | undefined;
    expiresAt?: Date | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: ICreateUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalUrl = _data["originalUrl"];
            this.customAlias = _data["customAlias"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (this.metadata as any)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalUrl"] = this.originalUrl;
        data["customAlias"] = this.customAlias;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (data["metadata"] as any)[key] = (this.metadata as any)[key];
            }
        }
        return data;
    }
}

export interface ICreateUrlDto {
    originalUrl: string;
    customAlias?: string | undefined;
    expiresAt?: Date | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class CreateUrlResponse implements ICreateUrlResponse {
    shortCode!: string | undefined;
    shortUrl!: string | undefined;
    originalUrl!: string | undefined;
    createdAt?: Date;
    userId?: string | undefined;
    expiresAt?: Date | undefined;
    error?: string | undefined;

    constructor(data?: ICreateUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.shortUrl = _data["shortUrl"];
            this.originalUrl = _data["originalUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.userId = _data["userId"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): CreateUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["shortUrl"] = this.shortUrl;
        data["originalUrl"] = this.originalUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["userId"] = this.userId;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["error"] = this.error;
        return data;
    }
}

export interface ICreateUrlResponse {
    shortCode: string | undefined;
    shortUrl: string | undefined;
    originalUrl: string | undefined;
    createdAt?: Date;
    userId?: string | undefined;
    expiresAt?: Date | undefined;
    error?: string | undefined;
}

export class CreateUrlResult implements ICreateUrlResult {
    index?: number;
    success?: boolean;
    shortCode?: string | undefined;
    shortUrl?: string | undefined;
    originalUrl!: string | undefined;
    expiresAt?: Date | undefined;
    error?: string | undefined;

    constructor(data?: ICreateUrlResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.success = _data["success"];
            this.shortCode = _data["shortCode"];
            this.shortUrl = _data["shortUrl"];
            this.originalUrl = _data["originalUrl"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): CreateUrlResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUrlResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["success"] = this.success;
        data["shortCode"] = this.shortCode;
        data["shortUrl"] = this.shortUrl;
        data["originalUrl"] = this.originalUrl;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["error"] = this.error;
        return data;
    }
}

export interface ICreateUrlResult {
    index?: number;
    success?: boolean;
    shortCode?: string | undefined;
    shortUrl?: string | undefined;
    originalUrl: string | undefined;
    expiresAt?: Date | undefined;
    error?: string | undefined;
}

export class DashboardOverviewDto implements IDashboardOverviewDto {
    totalUrls?: OverviewStatDto;
    totalClicks?: OverviewStatDto;
    activeUrls?: OverviewStatDto;
    uniqueVisitors?: OverviewStatDto;
    topUrls?: TopUrlDto[] | undefined;
    recentActivity?: RecentActivityDto[] | undefined;
    systemHealth?: SystemHealthDto;

    constructor(data?: IDashboardOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalUrls = _data["totalUrls"] ? OverviewStatDto.fromJS(_data["totalUrls"]) : undefined as any;
            this.totalClicks = _data["totalClicks"] ? OverviewStatDto.fromJS(_data["totalClicks"]) : undefined as any;
            this.activeUrls = _data["activeUrls"] ? OverviewStatDto.fromJS(_data["activeUrls"]) : undefined as any;
            this.uniqueVisitors = _data["uniqueVisitors"] ? OverviewStatDto.fromJS(_data["uniqueVisitors"]) : undefined as any;
            if (Array.isArray(_data["topUrls"])) {
                this.topUrls = [] as any;
                for (let item of _data["topUrls"])
                    this.topUrls!.push(TopUrlDto.fromJS(item));
            }
            if (Array.isArray(_data["recentActivity"])) {
                this.recentActivity = [] as any;
                for (let item of _data["recentActivity"])
                    this.recentActivity!.push(RecentActivityDto.fromJS(item));
            }
            this.systemHealth = _data["systemHealth"] ? SystemHealthDto.fromJS(_data["systemHealth"]) : undefined as any;
        }
    }

    static fromJS(data: any): DashboardOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalUrls"] = this.totalUrls ? this.totalUrls.toJSON() : undefined as any;
        data["totalClicks"] = this.totalClicks ? this.totalClicks.toJSON() : undefined as any;
        data["activeUrls"] = this.activeUrls ? this.activeUrls.toJSON() : undefined as any;
        data["uniqueVisitors"] = this.uniqueVisitors ? this.uniqueVisitors.toJSON() : undefined as any;
        if (Array.isArray(this.topUrls)) {
            data["topUrls"] = [];
            for (let item of this.topUrls)
                data["topUrls"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.recentActivity)) {
            data["recentActivity"] = [];
            for (let item of this.recentActivity)
                data["recentActivity"].push(item ? item.toJSON() : undefined as any);
        }
        data["systemHealth"] = this.systemHealth ? this.systemHealth.toJSON() : undefined as any;
        return data;
    }
}

export interface IDashboardOverviewDto {
    totalUrls?: OverviewStatDto;
    totalClicks?: OverviewStatDto;
    activeUrls?: OverviewStatDto;
    uniqueVisitors?: OverviewStatDto;
    topUrls?: TopUrlDto[] | undefined;
    recentActivity?: RecentActivityDto[] | undefined;
    systemHealth?: SystemHealthDto;
}

export class DateRangeDto implements IDateRangeDto {
    startDate?: Date;
    endDate?: Date;
    label?: string | undefined;

    constructor(data?: IDateRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): DateRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["label"] = this.label;
        return data;
    }
}

export interface IDateRangeDto {
    startDate?: Date;
    endDate?: Date;
    label?: string | undefined;
}

export class DeleteUrlResult implements IDeleteUrlResult {
    index?: number;
    shortCode!: string | undefined;
    success?: boolean;
    error?: string | undefined;

    constructor(data?: IDeleteUrlResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.shortCode = _data["shortCode"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): DeleteUrlResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteUrlResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["shortCode"] = this.shortCode;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }
}

export interface IDeleteUrlResult {
    index?: number;
    shortCode: string | undefined;
    success?: boolean;
    error?: string | undefined;
}

export class DeviceBreakdownDto implements IDeviceBreakdownDto {
    shortCode?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    totalAccesses?: number;
    deviceTypes?: DeviceCategoryDto[] | undefined;
    browsers?: DeviceCategoryDto[] | undefined;
    operatingSystems?: DeviceCategoryDto[] | undefined;
    mobileVsDesktop?: MobileVsDesktopDto;

    constructor(data?: IDeviceBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.totalAccesses = _data["totalAccesses"];
            if (Array.isArray(_data["deviceTypes"])) {
                this.deviceTypes = [] as any;
                for (let item of _data["deviceTypes"])
                    this.deviceTypes!.push(DeviceCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["browsers"])) {
                this.browsers = [] as any;
                for (let item of _data["browsers"])
                    this.browsers!.push(DeviceCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["operatingSystems"])) {
                this.operatingSystems = [] as any;
                for (let item of _data["operatingSystems"])
                    this.operatingSystems!.push(DeviceCategoryDto.fromJS(item));
            }
            this.mobileVsDesktop = _data["mobileVsDesktop"] ? MobileVsDesktopDto.fromJS(_data["mobileVsDesktop"]) : undefined as any;
        }
    }

    static fromJS(data: any): DeviceBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["totalAccesses"] = this.totalAccesses;
        if (Array.isArray(this.deviceTypes)) {
            data["deviceTypes"] = [];
            for (let item of this.deviceTypes)
                data["deviceTypes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.browsers)) {
            data["browsers"] = [];
            for (let item of this.browsers)
                data["browsers"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.operatingSystems)) {
            data["operatingSystems"] = [];
            for (let item of this.operatingSystems)
                data["operatingSystems"].push(item ? item.toJSON() : undefined as any);
        }
        data["mobileVsDesktop"] = this.mobileVsDesktop ? this.mobileVsDesktop.toJSON() : undefined as any;
        return data;
    }
}

export interface IDeviceBreakdownDto {
    shortCode?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    totalAccesses?: number;
    deviceTypes?: DeviceCategoryDto[] | undefined;
    browsers?: DeviceCategoryDto[] | undefined;
    operatingSystems?: DeviceCategoryDto[] | undefined;
    mobileVsDesktop?: MobileVsDesktopDto;
}

export class DeviceCategoryDto implements IDeviceCategoryDto {
    name?: string | undefined;
    count?: number;
    percentage?: number;
    color?: string | undefined;

    constructor(data?: IDeviceCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.count = _data["count"];
            this.percentage = _data["percentage"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): DeviceCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        data["color"] = this.color;
        return data;
    }
}

export interface IDeviceCategoryDto {
    name?: string | undefined;
    count?: number;
    percentage?: number;
    color?: string | undefined;
}

export enum DisableReason {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DisableUrlDto implements IDisableUrlDto {
    reason!: DisableReason;
    adminNotes?: string | undefined;
    notifyOwner?: boolean;

    constructor(data?: IDisableUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.adminNotes = _data["adminNotes"];
            this.notifyOwner = _data["notifyOwner"];
        }
    }

    static fromJS(data: any): DisableUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisableUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["adminNotes"] = this.adminNotes;
        data["notifyOwner"] = this.notifyOwner;
        return data;
    }
}

export interface IDisableUrlDto {
    reason: DisableReason;
    adminNotes?: string | undefined;
    notifyOwner?: boolean;
}

export class GeographicHeatmapDto implements IGeographicHeatmapDto {
    shortCode?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    totalAccesses?: number;
    countriesReached?: number;
    countries?: CountryDataDto[] | undefined;
    topRegions?: RegionDataDto[] | undefined;
    topCities?: CityDataDto[] | undefined;

    constructor(data?: IGeographicHeatmapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.totalAccesses = _data["totalAccesses"];
            this.countriesReached = _data["countriesReached"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(CountryDataDto.fromJS(item));
            }
            if (Array.isArray(_data["topRegions"])) {
                this.topRegions = [] as any;
                for (let item of _data["topRegions"])
                    this.topRegions!.push(RegionDataDto.fromJS(item));
            }
            if (Array.isArray(_data["topCities"])) {
                this.topCities = [] as any;
                for (let item of _data["topCities"])
                    this.topCities!.push(CityDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeographicHeatmapDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeographicHeatmapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["totalAccesses"] = this.totalAccesses;
        data["countriesReached"] = this.countriesReached;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.topRegions)) {
            data["topRegions"] = [];
            for (let item of this.topRegions)
                data["topRegions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.topCities)) {
            data["topCities"] = [];
            for (let item of this.topCities)
                data["topCities"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IGeographicHeatmapDto {
    shortCode?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    totalAccesses?: number;
    countriesReached?: number;
    countries?: CountryDataDto[] | undefined;
    topRegions?: RegionDataDto[] | undefined;
    topCities?: CityDataDto[] | undefined;
}

export class MobileVsDesktopDto implements IMobileVsDesktopDto {
    mobileCount?: number;
    mobilePercentage?: number;
    desktopCount?: number;
    desktopPercentage?: number;
    tabletCount?: number;
    tabletPercentage?: number;

    constructor(data?: IMobileVsDesktopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobileCount = _data["mobileCount"];
            this.mobilePercentage = _data["mobilePercentage"];
            this.desktopCount = _data["desktopCount"];
            this.desktopPercentage = _data["desktopPercentage"];
            this.tabletCount = _data["tabletCount"];
            this.tabletPercentage = _data["tabletPercentage"];
        }
    }

    static fromJS(data: any): MobileVsDesktopDto {
        data = typeof data === 'object' ? data : {};
        let result = new MobileVsDesktopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobileCount"] = this.mobileCount;
        data["mobilePercentage"] = this.mobilePercentage;
        data["desktopCount"] = this.desktopCount;
        data["desktopPercentage"] = this.desktopPercentage;
        data["tabletCount"] = this.tabletCount;
        data["tabletPercentage"] = this.tabletPercentage;
        return data;
    }
}

export interface IMobileVsDesktopDto {
    mobileCount?: number;
    mobilePercentage?: number;
    desktopCount?: number;
    desktopPercentage?: number;
    tabletCount?: number;
    tabletPercentage?: number;
}

export class OverviewStatDto implements IOverviewStatDto {
    value?: number;
    previousValue?: number;
    percentChange?: number;
    trend?: string | undefined;

    constructor(data?: IOverviewStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.previousValue = _data["previousValue"];
            this.percentChange = _data["percentChange"];
            this.trend = _data["trend"];
        }
    }

    static fromJS(data: any): OverviewStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new OverviewStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["previousValue"] = this.previousValue;
        data["percentChange"] = this.percentChange;
        data["trend"] = this.trend;
        return data;
    }
}

export interface IOverviewStatDto {
    value?: number;
    previousValue?: number;
    percentChange?: number;
    trend?: string | undefined;
}

export class PopularUrl implements IPopularUrl {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    accessCount?: number;
    trendScore?: number;

    constructor(data?: IPopularUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.accessCount = _data["accessCount"];
            this.trendScore = _data["trendScore"];
        }
    }

    static fromJS(data: any): PopularUrl {
        data = typeof data === 'object' ? data : {};
        let result = new PopularUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["accessCount"] = this.accessCount;
        data["trendScore"] = this.trendScore;
        return data;
    }
}

export interface IPopularUrl {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    accessCount?: number;
    trendScore?: number;
}

export class PreviewResponse implements IPreviewResponse {
    shortCode!: string | undefined;
    originalUrl!: string | undefined;
    createdAt!: Date;
    accessCount!: number;
    shortUrl!: string | undefined;
    isActive?: boolean;
    expiresAt?: Date | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.accessCount = _data["accessCount"];
            this.shortUrl = _data["shortUrl"];
            this.isActive = _data["isActive"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (this.metadata as any)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): PreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["accessCount"] = this.accessCount;
        data["shortUrl"] = this.shortUrl;
        data["isActive"] = this.isActive;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (data["metadata"] as any)[key] = (this.metadata as any)[key];
            }
        }
        return data;
    }
}

export interface IPreviewResponse {
    shortCode: string | undefined;
    originalUrl: string | undefined;
    createdAt: Date;
    accessCount: number;
    shortUrl: string | undefined;
    isActive?: boolean;
    expiresAt?: Date | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RecentActivityDto implements IRecentActivityDto {
    timestamp?: Date;
    type?: string | undefined;
    shortCode?: string | undefined;
    details?: string | undefined;

    constructor(data?: IRecentActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : undefined as any;
            this.type = _data["type"];
            this.shortCode = _data["shortCode"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): RecentActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecentActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined as any;
        data["type"] = this.type;
        data["shortCode"] = this.shortCode;
        data["details"] = this.details;
        return data;
    }
}

export interface IRecentActivityDto {
    timestamp?: Date;
    type?: string | undefined;
    shortCode?: string | undefined;
    details?: string | undefined;
}

export class RegionDataDto implements IRegionDataDto {
    countryCode?: string | undefined;
    regionName?: string | undefined;
    clicks?: number;
    percentage?: number;

    constructor(data?: IRegionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.regionName = _data["regionName"];
            this.clicks = _data["clicks"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): RegionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["regionName"] = this.regionName;
        data["clicks"] = this.clicks;
        data["percentage"] = this.percentage;
        return data;
    }
}

export interface IRegionDataDto {
    countryCode?: string | undefined;
    regionName?: string | undefined;
    clicks?: number;
    percentage?: number;
}

export class SystemHealthDto implements ISystemHealthDto {
    cacheHitRate?: number;
    avgResponseTimeMs?: number;
    activeConnections?: number;
    status?: string | undefined;

    constructor(data?: ISystemHealthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheHitRate = _data["cacheHitRate"];
            this.avgResponseTimeMs = _data["avgResponseTimeMs"];
            this.activeConnections = _data["activeConnections"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SystemHealthDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemHealthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheHitRate"] = this.cacheHitRate;
        data["avgResponseTimeMs"] = this.avgResponseTimeMs;
        data["activeConnections"] = this.activeConnections;
        data["status"] = this.status;
        return data;
    }
}

export interface ISystemHealthDto {
    cacheHitRate?: number;
    avgResponseTimeMs?: number;
    activeConnections?: number;
    status?: string | undefined;
}

export class TimeSeriesAggregateDto implements ITimeSeriesAggregateDto {
    totalClicks?: number;
    totalUniqueVisitors?: number;
    peakHourClicks?: number;
    peakHour?: Date;
    avgClicksPerInterval?: number;

    constructor(data?: ITimeSeriesAggregateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalClicks = _data["totalClicks"];
            this.totalUniqueVisitors = _data["totalUniqueVisitors"];
            this.peakHourClicks = _data["peakHourClicks"];
            this.peakHour = _data["peakHour"] ? new Date(_data["peakHour"].toString()) : undefined as any;
            this.avgClicksPerInterval = _data["avgClicksPerInterval"];
        }
    }

    static fromJS(data: any): TimeSeriesAggregateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesAggregateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalClicks"] = this.totalClicks;
        data["totalUniqueVisitors"] = this.totalUniqueVisitors;
        data["peakHourClicks"] = this.peakHourClicks;
        data["peakHour"] = this.peakHour ? this.peakHour.toISOString() : undefined as any;
        data["avgClicksPerInterval"] = this.avgClicksPerInterval;
        return data;
    }
}

export interface ITimeSeriesAggregateDto {
    totalClicks?: number;
    totalUniqueVisitors?: number;
    peakHourClicks?: number;
    peakHour?: Date;
    avgClicksPerInterval?: number;
}

export class TimeSeriesDataDto implements ITimeSeriesDataDto {
    shortCode?: string | undefined;
    interval?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    points?: TimeSeriesPointDto[] | undefined;
    aggregates?: TimeSeriesAggregateDto;

    constructor(data?: ITimeSeriesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.interval = _data["interval"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(TimeSeriesPointDto.fromJS(item));
            }
            this.aggregates = _data["aggregates"] ? TimeSeriesAggregateDto.fromJS(_data["aggregates"]) : undefined as any;
        }
    }

    static fromJS(data: any): TimeSeriesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["interval"] = this.interval;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item ? item.toJSON() : undefined as any);
        }
        data["aggregates"] = this.aggregates ? this.aggregates.toJSON() : undefined as any;
        return data;
    }
}

export interface ITimeSeriesDataDto {
    shortCode?: string | undefined;
    interval?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    points?: TimeSeriesPointDto[] | undefined;
    aggregates?: TimeSeriesAggregateDto;
}

export class TimeSeriesPointDto implements ITimeSeriesPointDto {
    timestamp?: Date;
    clicks?: number;
    uniqueVisitors?: number;
    avgResponseTime?: number;

    constructor(data?: ITimeSeriesPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : undefined as any;
            this.clicks = _data["clicks"];
            this.uniqueVisitors = _data["uniqueVisitors"];
            this.avgResponseTime = _data["avgResponseTime"];
        }
    }

    static fromJS(data: any): TimeSeriesPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined as any;
        data["clicks"] = this.clicks;
        data["uniqueVisitors"] = this.uniqueVisitors;
        data["avgResponseTime"] = this.avgResponseTime;
        return data;
    }
}

export interface ITimeSeriesPointDto {
    timestamp?: Date;
    clicks?: number;
    uniqueVisitors?: number;
    avgResponseTime?: number;
}

export class TopUrlDto implements ITopUrlDto {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    clicks?: number;
    percentOfTotal?: number;

    constructor(data?: ITopUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.clicks = _data["clicks"];
            this.percentOfTotal = _data["percentOfTotal"];
        }
    }

    static fromJS(data: any): TopUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["clicks"] = this.clicks;
        data["percentOfTotal"] = this.percentOfTotal;
        return data;
    }
}

export interface ITopUrlDto {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    clicks?: number;
    percentOfTotal?: number;
}

export class UpdateUrlResult implements IUpdateUrlResult {
    index?: number;
    shortCode!: string | undefined;
    success?: boolean;
    error?: string | undefined;

    constructor(data?: IUpdateUrlResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.shortCode = _data["shortCode"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): UpdateUrlResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUrlResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["shortCode"] = this.shortCode;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }
}

export interface IUpdateUrlResult {
    index?: number;
    shortCode: string | undefined;
    success?: boolean;
    error?: string | undefined;
}

export class UrlExpirationUpdate implements IUrlExpirationUpdate {
    shortCode!: string | undefined;
    expiresAt?: Date | undefined;

    constructor(data?: IUrlExpirationUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UrlExpirationUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new UrlExpirationUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUrlExpirationUpdate {
    shortCode: string | undefined;
    expiresAt?: Date | undefined;
}

export class UrlPreviewResponse implements IUrlPreviewResponse {
    shortCode!: string | undefined;
    originalUrl!: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    siteName?: string | undefined;
    faviconUrl?: string | undefined;
    type?: string | undefined;
    fetchedAt?: Date;

    constructor(data?: IUrlPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.siteName = _data["siteName"];
            this.faviconUrl = _data["faviconUrl"];
            this.type = _data["type"];
            this.fetchedAt = _data["fetchedAt"] ? new Date(_data["fetchedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UrlPreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UrlPreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["siteName"] = this.siteName;
        data["faviconUrl"] = this.faviconUrl;
        data["type"] = this.type;
        data["fetchedAt"] = this.fetchedAt ? this.fetchedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUrlPreviewResponse {
    shortCode: string | undefined;
    originalUrl: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    siteName?: string | undefined;
    faviconUrl?: string | undefined;
    type?: string | undefined;
    fetchedAt?: Date;
}

export class UrlStatistics implements IUrlStatistics {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    accessCount?: number;
    createdAt?: Date;
    lastAccessedAt?: Date | undefined;
    expiresAt?: Date | undefined;
    status?: UrlStatus;
    countryStats?: { [key: string]: number; } | undefined;
    deviceStats?: { [key: string]: number; } | undefined;
    referrerStats?: { [key: string]: number; } | undefined;

    constructor(data?: IUrlStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.accessCount = _data["accessCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.lastAccessedAt = _data["lastAccessedAt"] ? new Date(_data["lastAccessedAt"].toString()) : undefined as any;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.status = _data["status"];
            if (_data["countryStats"]) {
                this.countryStats = {} as any;
                for (let key in _data["countryStats"]) {
                    if (_data["countryStats"].hasOwnProperty(key))
                        (this.countryStats as any)![key] = _data["countryStats"][key];
                }
            }
            if (_data["deviceStats"]) {
                this.deviceStats = {} as any;
                for (let key in _data["deviceStats"]) {
                    if (_data["deviceStats"].hasOwnProperty(key))
                        (this.deviceStats as any)![key] = _data["deviceStats"][key];
                }
            }
            if (_data["referrerStats"]) {
                this.referrerStats = {} as any;
                for (let key in _data["referrerStats"]) {
                    if (_data["referrerStats"].hasOwnProperty(key))
                        (this.referrerStats as any)![key] = _data["referrerStats"][key];
                }
            }
        }
    }

    static fromJS(data: any): UrlStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new UrlStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["accessCount"] = this.accessCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["lastAccessedAt"] = this.lastAccessedAt ? this.lastAccessedAt.toISOString() : undefined as any;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["status"] = this.status;
        if (this.countryStats) {
            data["countryStats"] = {};
            for (let key in this.countryStats) {
                if (this.countryStats.hasOwnProperty(key))
                    (data["countryStats"] as any)[key] = (this.countryStats as any)[key];
            }
        }
        if (this.deviceStats) {
            data["deviceStats"] = {};
            for (let key in this.deviceStats) {
                if (this.deviceStats.hasOwnProperty(key))
                    (data["deviceStats"] as any)[key] = (this.deviceStats as any)[key];
            }
        }
        if (this.referrerStats) {
            data["referrerStats"] = {};
            for (let key in this.referrerStats) {
                if (this.referrerStats.hasOwnProperty(key))
                    (data["referrerStats"] as any)[key] = (this.referrerStats as any)[key];
            }
        }
        return data;
    }
}

export interface IUrlStatistics {
    shortCode?: string | undefined;
    originalUrl?: string | undefined;
    accessCount?: number;
    createdAt?: Date;
    lastAccessedAt?: Date | undefined;
    expiresAt?: Date | undefined;
    status?: UrlStatus;
    countryStats?: { [key: string]: number; } | undefined;
    deviceStats?: { [key: string]: number; } | undefined;
    referrerStats?: { [key: string]: number; } | undefined;
}

export enum UrlStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class UrlValidationResponse implements IUrlValidationResponse {
    shortCode!: string | undefined;
    originalUrl!: string | undefined;
    isSafe?: boolean;
    isAccessible?: boolean;
    httpStatusCode?: number;
    responseTime?: string;
    hasSSL?: boolean;
    validatedAt?: Date;

    constructor(data?: IUrlValidationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortCode = _data["shortCode"];
            this.originalUrl = _data["originalUrl"];
            this.isSafe = _data["isSafe"];
            this.isAccessible = _data["isAccessible"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.responseTime = _data["responseTime"];
            this.hasSSL = _data["hasSSL"];
            this.validatedAt = _data["validatedAt"] ? new Date(_data["validatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UrlValidationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UrlValidationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortCode"] = this.shortCode;
        data["originalUrl"] = this.originalUrl;
        data["isSafe"] = this.isSafe;
        data["isAccessible"] = this.isAccessible;
        data["httpStatusCode"] = this.httpStatusCode;
        data["responseTime"] = this.responseTime;
        data["hasSSL"] = this.hasSSL;
        data["validatedAt"] = this.validatedAt ? this.validatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUrlValidationResponse {
    shortCode: string | undefined;
    originalUrl: string | undefined;
    isSafe?: boolean;
    isAccessible?: boolean;
    httpStatusCode?: number;
    responseTime?: string;
    hasSSL?: boolean;
    validatedAt?: Date;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}